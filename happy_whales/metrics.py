# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/metrics.ipynb (unless otherwise specified).

__all__ = ['TopKAccuracy', 'map_per_image', 'map_per_set']

# Cell
import numpy as np
import torch

# Cell
class TopKAccuracy:
    def __init__(self, k=5, device="cpu"):
        self._k = k
        self._device = device

        self._correct = 0
        self._total = 0

    def reset(self):
        self._correct = 0
        self._total = 0

    @torch.no_grad()
    def compute(self, output, target):
        output = output.to(self._device)
        target = target.to(self._device)

        _, pred = output.topk(self._k, 1)
        pred = pred[:, :self._k]
        print(pred)
        expanded_y = target.view(-1, 1).expand(-1, self._k)
        print(expanded_y)
        correct = torch.sum(torch.eq(pred, expanded_y), dim=1)
        print(correct)

        correct = pred.isin(target.view(-1, 1))

        print(correct)
        #self._correct +=
        self._total += target.size(0)

    @torch.no_grad()
    def update(self, output, target):
        self.compute(output, target)

    def get_metric(self):
        return self._correct.item() / self._total

# Cell
def map_per_image(label, predictions):
    try:
        return 1 / (predictions[:5].index(label) + 1)
    except ValueError:
        return 0.0

# Cell
def map_per_set(labels, predictions):
    return np.mean([map_per_image(l, p) for l,p in zip(labels, predictions)])